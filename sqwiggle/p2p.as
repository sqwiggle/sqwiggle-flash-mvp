package sqwiggle {	import flash.display.LoaderInfo;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.external.ExternalInterface;	import flash.net.NetConnection;	import flash.events.MouseEvent;	import sqwiggle.Self;	import sqwiggle.Member;	import sqwiggle.Conversation;	import sqwiggle.VideoPanel;	import flash.media.Video;	import flash.events.Event;	import flash.utils.Dictionary;		public class p2p extends Sprite {				var parameters 			:Object;		var self      			:Self;		var conversation		:Conversation;		var panel				:VideoPanel;				public function p2p() {			parameters = LoaderInfo(this.root.loaderInfo).parameters;			stage.align = StageAlign.TOP;						trace('p2p', parameters.userId);			ExternalInterface.addCallback('addMembers', addMembers);			ExternalInterface.addCallback('addMember',  addMember);			ExternalInterface.addCallback('removeMember',  removeMember);			ExternalInterface.addCallback('addConversationMembers',  addConversationMembers);			//ExternalInterface.addCallback('removeConversationMember',  updateConversation);			self = new Self(parameters.userId);			panel = new VideoPanel(self);						addChild(panel);		}						/*		 * addMembers		 *		 * When joining a chat for the first time this method is called		 * to connect all of the existing participants in the video call.		*/		public function addMembers(strIds:String, strPeerIds:String):void {			trace('addMembers', strIds, strPeerIds);						// convert comma separated input into array of ids			var userIds:Array = strIds.split(',');			var peerIds:Array = strPeerIds.split(',');						for (var i = 0; i < peerIds.length; i++) {				addMember(userIds[i], peerIds[i]);			}		}						/*		 * addMember		 *		 * When a new user joins the chat this method is called to connect		 * them to the stream		*/		public function addMember(memberId:String, peerId:String):void {			trace('addMember', memberId, peerId);						// prevent multiple connections if the user opens another tab			if (self.userId === memberId) return;						// create a new member			var member:Member = new Member(memberId, peerId);			member.addEventListener(MouseEvent.CLICK, toggleInConversation);						// add to the video panel			panel.addMember(member);		}						/*		 * removeMember		 *		 * When an existing user leaves the room or is otherwise disconnected		 * from the video feed.		*/		public function removeMember(memberId:String) {			trace('removeMember', memberId);			panel.removeMember(memberId);		}						/*		 * addConversationMembers		 *		 * Whenever the participants in an audio conversation changes this method		 * is triggered with the new peers. This is currently instead of doing add and		 * remove so we don't need to store the conversationalists on the server.		 * TODO: store them on the server.		*/		public function addConversationMembers(conversationId:String, strIds:String):void {			trace('addConversationMembers', strIds);						var userIds:Array = strIds.split(',');			var members:Dictionary = panel.getMembers();						if (!conversation) {				trace('joining existing conversation', conversationId);				conversation = new Conversation(conversationId);			}						if (conversation.id != conversationId) {				trace('already in another conversation');				return;			}						// check if we are in this conversation that we've received an update for.			var filter = userIds.filter(function(memberId){ return memberId == this.userId; }, self);			var inConversation = !!filter.length;						if (inConversation) {				trace('were in this convo');				conversation.addMember(self);			} else {				trace('were not in this convo');				conversation.removeMember(self);			}						// for all members in the video panel			memberLoop: for (var j in members) {				var member = members[j];								if (!inConversation) {					conversation.removeMember(member);					continue;				}								// for all the peers in the conversation				for (var i = 0; i < userIds.length; i++) {					// if this member should be in the conversation					if (member.userId == userIds[i]) {						conversation.addMember(member);						continue memberLoop;					}				}								trace('not in conversation ' + member.userId);				// no longer in conversation				conversation.removeMember(member);			}												// last person has been removed			if (conversation.isEmpty()) {				conversation.removeMember(self);				conversation = null;			}		}						private function toggleInConversation(event:MouseEvent):void {			trace('toggleInConversation');			var member = event.target;						if (!conversation) {				trace('starting new conversation');				conversation = new Conversation();			}						// toggle			if (conversation.hasMember(member)) {				conversation.removeMember(member);			} else {				conversation.addMember(self);				conversation.addMember(member);			}						sendConversationUpdate();		}						private function sendConversationUpdate():void {			trace('sendConversationUpdate');						var userIds:Array = new Array();			var members:Dictionary = conversation.getMembers();						for (var i in members) {				userIds.push(members[i].userId);			}						ExternalInterface.call('sendConversationUpdate', conversation.id, userIds.join(','));		}	}}