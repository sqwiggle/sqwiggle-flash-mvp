package sqwiggle {	import flash.display.LoaderInfo;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.events.NetStatusEvent;	import flash.external.ExternalInterface;	import flash.net.NetConnection;	import flash.events.MouseEvent;	import sqwiggle.Self;	import sqwiggle.Member;		public class p2p extends Sprite {		var flashvars 			:Object;		var videoConnection		:NetConnection;		var audioConnection		:NetConnection;		var self      			:Self;		var members   			:Array;		var conversation		:Array;		var conversationInitiator :Boolean;				public function p2p() {			flashvars = LoaderInfo(this.root.loaderInfo).parameters;			members   = new Array();			conversation = new Array();						stage.align = StageAlign.TOP;						ExternalInterface.addCallback('addMembers', addMembers);			ExternalInterface.addCallback('addMember',  addMember);			ExternalInterface.addCallback('removeMember',  removeMember);			ExternalInterface.addCallback('updateAudioChannel',  updateAudioChannel);						videoConnection = new NetConnection();			videoConnection.addEventListener(NetStatusEvent.NET_STATUS, onVideoStatus);			videoConnection.connect('rtmfp://p2p.rtmfp.net', '56ec6665a4c675c72fb85db7-b6153286fa1e');						var client:Object = new Object();						client.onRelay = function(id:String):void {				trace('onRelay: ' + id);			}						videoConnection.client = client;		}				private function onVideoStatus(e:NetStatusEvent):void {			switch (e.info.code) {				case 'NetConnection.Connect.Success':					self = new Self(flashvars.self_id, videoConnection.nearID);					self.connectToVideo(videoConnection);					addChild(self);										trace('adding self (`id` => ' + flashvars.self_id + ', `peerId` => ' + videoConnection.nearID)										ExternalInterface.call('update_peer_id', flashvars.self_id, videoConnection.nearID);				break;			}		}				public function addMembers(strIds:String, strPeerIds:String):void {			trace(strIds, strPeerIds);						var ids    :Array = strIds    .split(',');			var peerIds:Array = strPeerIds.split(',');						for (var i = 0; i < peerIds.length; i++) {				if (peerIds[i] != videoConnection.nearID) addMember(ids[i], peerIds[i]);			}		}				public function updateAudioChannel(strIds:String, strPeerIds:String):void {			trace('Updating conversation with users', strIds);						var userIds:Array = strIds    .split(',');			var peerIds:Array = strPeerIds.split(',');						if (audioConnection) {				// TODO: handle this			} else {				trace('creating new audio connection');								audioConnection = new NetConnection();				audioConnection.addEventListener(NetStatusEvent.NET_STATUS, onAudioStatus);				audioConnection.connect('rtmfp://p2p.rtmfp.net', '56ec6665a4c675c72fb85db7-b6153286fa1e');			}						conversation = new Array();						trace(userIds);						// for all the peers in the conversation			for (var i = 0; i < userIds.length; i++) {				// for all members in the company				for (var j in members) {					trace(members[j].userId + " == " + userIds[i]);										// if this member should be in the conversation					if (members[j].userId == userIds[i]) {						trace('adding member to conversation', members[j].userId);												members[j].audioPeerId = peerIds[i];						conversation.push(members[j]);						break;					}				}			}		}				public function addMember(memberId:String, peerId:String):void {			// prevent multiple connections if the user opens another tab			if (self.userId === memberId) return;						trace('new member (`id` => ' + memberId + ', `peerId` => ' + peerId)						var member:Member = new Member(memberId, peerId);			member.connectToVideo(videoConnection);			member.addEventListener(MouseEvent.CLICK, createAudioChannel);			addChild(member);						members.push(member);			//trace(members.length + ' .. x: ' + 320*((members.length) % 3) + ' y: ' + 240*(Math.ceil((members.length) / 3)));						member.x = member.width  *           (members.length % 3);			member.y = member.height * (Math.ceil((members.length+1) / 3)-1);			trace('pos: ' + member.x + ', ' + member.y + ', members: ' + members.length);		}				public function removeMember(id:String) {			trace('member left (`id` => ' + id + ')');						for (var i = 0; i < members.length; i++) {				var member = members[i];								if (member.userId === id) {					member.remove();					removeChild(member);										members.splice(i, 1);					break;				}			}						for (i = 0; i < members.length; i++) {				member = members[i];				member.x = member.width  *           ((i+1) % 3);				member.y = member.height * (Math.ceil((i+2) / 3)-1);								trace('repos: ' + member.x + ', ' + member.y + ', members: ' + members.length);			}		}				private function createAudioChannel(event:MouseEvent):void {						// already existing connection			if (audioConnection) {								// TODO: make sure that this connection is to the correct people				// TODO: ensure mic is unmuted									// no connection available, were creating a new audio chat			} else {				trace('Initialising new conversation');				conversationInitiator = true;				// create a new audio channel				audioConnection = new NetConnection();				audioConnection.addEventListener(NetStatusEvent.NET_STATUS, onAudioStatus);				audioConnection.connect('rtmfp://p2p.rtmfp.net', '56ec6665a4c675c72fb85db7-b6153286fa1e');								// add this user to the conversation				conversation.push(event.target);				conversation.push(self);			}		}				private function onAudioStatus(e:NetStatusEvent):void {			switch (e.info.code) {				case 'NetConnection.Connect.Success':					trace('audio NetConnection.Connect.Success');										// connect to the stream ourselves					self.connectToAudio(audioConnection, audioConnection.nearID);										if (conversationInitiator) {												// and add people in conversation to the stream						sendAudioRequests();					} else {						connectAudioChannels();					}									break;			}		}						private function connectAudioChannels():void {			trace('connectAudioChannels ' + conversation.length);						for (var i in conversation){								// check that it isn't ourself				if (conversation[i].audioPeerId != audioConnection.nearID) {										trace('connectAudioChannels, connecting ' + conversation[i].userId);					conversation[i].connectToAudio(audioConnection, conversation[i].audioPeerId);				}			}		}						private function sendAudioRequests():void {			trace('Sending audio requests');						var userIds:Array = new Array();			var peerIds:Array = new Array();			for (var i in conversation) {				userIds.push(conversation[i].userId);				peerIds.push(conversation[i].peerId);			}						for (var j in conversation) {				if (conversation[j].userId === self.userId) return;								ExternalInterface.call('sendAudioRequest', conversation[j].userId, userIds.join(','), peerIds.join(','));			}		}	}}