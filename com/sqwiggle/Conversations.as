package com.sqwiggle {	import com.sqwiggle.Conversation;	import com.sqwiggle.Self;	import com.sqwiggle.events.ApiEvent;	import flash.events.Event;	import flash.net.URLLoader;	import flash.events.EventDispatcher;		public class Conversations extends EventDispatcher {				private var ongoing:Object;		private var colours:Array;		private var self:Self;		public var members:Object;				public function Conversations(self:Self, members:Object) {			this.ongoing = new Object();			this.members = members;			this.self = self;						// make an API request to get ongoing conversations			var request = Api.getRequest('/conversations');						request.addEventListener(Event.COMPLETE, function(event:ApiEvent) {				updateMembers(event.data.conversations);			});		}						public function updateMembers(conversations:Object):void {									// first find if the current user is in any conversation			var selfInConversation = false;						for (var a in conversations) {				for (var b in conversations[a].users) {					if (conversations[a].users[b].id == self.userId) {						selfInConversation = a;					}				}			}						for (var i in conversations) {				trace('updating conversation', i);								// we dont know about this conversation				if (!ongoing[i]) {					ongoing[i] = new Conversation();					ongoing[i].id = i; 				}								var conversation = ongoing[i];				var existingMembers = conversation.members;				var selfInCurrentConversation = selfInConversation == i;								// find existing members that should leave the convo				for (var j in existingMembers) {										// check if this user is still in the convo					var filter = conversations[i].users.filter(function(user){ return user.id == this.userId; }, existingMembers[j]);					var inConversation = !!filter.length;										if (!inConversation) {						trace('removing member from conversation', member.userId, conversation.id);						conversation.removeMember(member, selfInCurrentConversation);					}				}				// for every user that should be in this conversation				for (var k in conversations[i].users) {					var user = conversations[i].users[k];					var member;										if (user.id == self.userId) {						member = self;					} else {						member = members[user.id];					}										if (!member) {						continue;					}										if (!conversation.hasMember(member)) {												if (selfInCurrentConversation) {							trace('member already in a conversation with you');						} else {							trace('adding member to conversation', member.userId, conversation.id);						}						conversation.addMember(member, selfInCurrentConversation);					}				}			}						dispatchEvent(new Event("conversationsupdated"));		}						public function getConversationForMember(member:Member):Conversation {			for (var i in ongoing) {				if (ongoing[i].hasMember(member)) {					return ongoing[i];				}			}						return null;		}						private function nextColour():void {					}	}}